var_names,
measure = "OR",
title = "Adjusted Model Results",
fallacy_safe = TRUE) {
# Ensure required packages are loaded
if (!requireNamespace("dplyr", quietly = TRUE)) stop("Package 'dplyr' is required.")
if (!requireNamespace("knitr", quietly = TRUE)) stop("Package 'knitr' is required.")
if (!requireNamespace("kableExtra", quietly = TRUE)) stop("Package 'kableExtra' is required.")
if (!requireNamespace("stringr", quietly = TRUE)) stop("Package 'stringr' is required.")
# Get a summary data frame, removing the intercept
summary_df <- summary(pooled_model, conf.int = TRUE, exponentiate = TRUE) %>%
filter(term != "(Intercept)")
# Create a robust pattern from the provided variable names
pattern <- paste(var_names, collapse = "|")
processed_results <- summary_df %>%
select(term, estimate, conf.low, conf.high, p.value) %>%
mutate(
group = stringr::str_extract(term, pattern),
Characteristic = stringr::str_remove(term, pattern),
Estimate_CI = sprintf("%.2f (%.2f, %.2f)", estimate, conf.low, conf.high),
p_value_formatted = case_when(
p.value < 0.001 ~ "<0.001",
TRUE ~ sprintf("%.3f", p.value)
)
) %>%
select(group, Characteristic, Estimate_CI, p_value_formatted)
# Conditionally filter for fallacy-safe output
if (fallacy_safe) {
if (!main_exposure %in% processed_results$group) {
stop(paste("Main exposure '", main_exposure, "' not found in model terms.", sep=""))
}
results_to_display <- processed_results %>% filter(group == main_exposure)
confounder_vars <- var_names[!var_names %in% main_exposure]
footnote_text <- paste("Adjusted for:", paste(confounder_vars, collapse = ", "))
} else {
results_to_display <- processed_results
}
# Create the base kable table
final_table <- kable(
results_to_display[, -1],
col.names = c("Characteristic", paste(measure, "(95% CI)"), "p-value"),
align = "lcc",
caption = title,
row.names = FALSE
) %>%
kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE)
# FIX: Only call pack_rows if we are showing the full table
if (!fallacy_safe) {
final_table <- final_table %>%
pack_rows(index = table(factor(results_to_display$group, levels = var_names)))
}
# Add the footnote only if in fallacy-safe mode
if (fallacy_safe) {
final_table <- final_table %>%
footnote(general = footnote_text, footnote_as_chunk = TRUE, general_title = " ")
}
return(final_table)
}
publish_pooled_results(pooled_results,
main_exposure = "Smoke100",
var_names = c("AgeCat", "Smoke100", "Education"),
measure = "OR",
title = "Adjusted Odds Ratios for Obesity",
fallacy_safe = TRUE)
publish_pooled_results(pooled_results,
main_exposure = "Smoke100",
var_names = c("AgeCat", "Smoke100", "Education"),
measure = "OR",
title = "Adjusted Odds Ratios for Obesity",
fallacy_safe = FALSE)
#' Create a Publication-Ready Table for Pooled Model Results (Final Version)
#'
#' This function takes a pooled model object from 'mice' and creates a
#' formatted HTML table of effect estimates. It can produce a "fallacy-safe"
#' table showing only the main exposure or a full table with all variables.
#'
#' @param pooled_model A 'mipo' object from `mice::pool()`.
#' @param main_exposure The character string of the main exposure variable.
#' @param adj_var_names A character vector of all adjustment variable names in the model.
#' @param measure A character string for the effect measure (e.g., "OR", "HR").
#' @param title A character string for the table's caption.
#' @param fallacy_safe Logical. If TRUE, only shows the main exposure.
#'
#' @return An HTML table object from 'kableExtra'.
publish_pooled_results <- function(pooled_model,
main_exposure,
adj_var_names,
measure = "OR",
title = "Adjusted Model Results",
fallacy_safe = TRUE) {
# Ensure required packages are loaded
if (!requireNamespace("dplyr", quietly = TRUE)) stop("Package 'dplyr' is required.")
if (!requireNamespace("knitr", quietly = TRUE)) stop("Package 'knitr' is required.")
if (!requireNamespace("kableExtra", quietly = TRUE)) stop("Package 'kableExtra' is required.")
if (!requireNamespace("stringr", quietly = TRUE)) stop("Package 'stringr' is required.")
# Get a summary data frame, removing the intercept
summary_df <- summary(pooled_model, conf.int = TRUE, exponentiate = TRUE) %>%
filter(term != "(Intercept)")
# Combine all variable names for parsing
all_vars <- c(main_exposure, adj_var_names)
pattern <- paste(all_vars, collapse = "|")
processed_results <- summary_df %>%
select(term, estimate, conf.low, conf.high, p.value) %>%
mutate(
# Reliably extract the group and characteristic
group = stringr::str_extract(term, pattern),
Characteristic = stringr::str_remove(term, pattern),
Estimate_CI = sprintf("%.2f (%.2f, %.2f)", estimate, conf.low, conf.high),
p_value_formatted = case_when(
p.value < 0.001 ~ "<0.001",
TRUE ~ sprintf("%.3f", p.value)
)
) %>%
select(group, Characteristic, Estimate_CI, p_value_formatted)
# Conditionally filter for fallacy-safe output
if (fallacy_safe) {
if (!main_exposure %in% processed_results$group) {
stop(paste("Main exposure '", main_exposure, "' not found in model terms.", sep=""))
}
results_to_display <- processed_results %>% filter(group == main_exposure)
footnote_text <- paste("Adjusted for:", paste(adj_var_names, collapse = ", "))
} else {
results_to_display <- processed_results
}
# Create the final kable table
final_table <- kable(
results_to_display[, -1], # Remove helper 'group' column
col.names = c("Characteristic", paste(measure, "(95% CI)"), "p-value"),
align = "lcc",
caption = title,
row.names = FALSE
) %>%
kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE) %>%
# This now works for both single and multiple groups
pack_rows(index = table(factor(results_to_display$group, levels = all_vars)))
if (fallacy_safe) {
final_table <- final_table %>%
footnote(general = footnote_text, footnote_as_chunk = TRUE, general_title = " ")
}
return(final_table)
}
# --- 1. Load Packages ---
library(NHANES)
library(dplyr)
library(mice)
library(survey)
library(knitr)
library(kableExtra)
library(stringr)
# --- 2. Paste the FINAL 'publish_pooled_results' function here ---
# ... (function code from above) ...
# --- 3. Prepare Data ---
data(NHANESraw, package = "NHANES")
nhanes_analytic <- NHANESraw %>%
filter(Age >= 20 & WTMEC2YR > 0) %>%
mutate(
Obese = factor(ifelse(BMI >= 30, "Yes", "No"), levels = c("No", "Yes")),
AgeCat = cut(Age, breaks = c(19, 39, 59, 80), labels = c("20-39", "40-59", "60-80")),
Smoke100 = factor(Smoke100, levels = c("No", "Yes"))
) %>%
select(Obese, AgeCat, Smoke100, Education, SDMVPSU, SDMVSTRA, WTMEC2YR)
# --- 4. Impute & Analyze ---
imputed_data <- mice(nhanes_analytic, m = 2, maxit = 2, seed = 123, printFlag = FALSE)
fit_list <- list()
for (i in 1:imputed_data$m) {
completed_data <- complete(imputed_data, i)
design_i <- svydesign(id = ~SDMVPSU, strata = ~SDMVSTRA, weights = ~WTMEC2YR, nest = TRUE, data = completed_data)
fit_list[[i]] <- svyglm(Obese ~ Smoke100 + AgeCat + Education, design = design_i, family = quasibinomial())
}
pooled_results <- pool(fit_list)
# --- 5. Generate the Tables ---
# Fallacy-safe table (will now have the correct header)
publish_pooled_results(pooled_results,
main_exposure = "Smoke100",
adj_var_names = c("AgeCat", "Education"), # <-- New argument
measure = "OR",
title = "Adjusted Odds Ratios for Obesity")
#' Create a Publication-Ready Table for Pooled Model Results (Final, Corrected Version)
#'
#' This function takes a pooled model object from 'mice' and creates a
#' formatted HTML table of effect estimates. It can produce a "fallacy-safe"
#' table showing only the main exposure or a full table with all variables.
#'
#' @param pooled_model A 'mipo' object from `mice::pool()`.
#' @param main_exposure The character string of the main exposure variable.
#' @param adj_var_names A character vector of all adjustment variable names in the model.
#' @param measure A character string for the effect measure (e.g., "OR", "HR").
#' @param title A character string for the table's caption.
#' @param fallacy_safe Logical. If TRUE, only shows the main exposure.
#'
#' @return An HTML table object from 'kableExtra'.
publish_pooled_results <- function(pooled_model,
main_exposure,
adj_var_names,
measure = "OR",
title = "Adjusted Model Results",
fallacy_safe = TRUE) {
# Ensure required packages are loaded
if (!requireNamespace("dplyr", quietly = TRUE)) stop("Package 'dplyr' is required.")
if (!requireNamespace("knitr", quietly = TRUE)) stop("Package 'knitr' is required.")
if (!requireNamespace("kableExtra", quietly = TRUE)) stop("Package 'kableExtra' is required.")
if (!requireNamespace("stringr", quietly = TRUE)) stop("Package 'stringr' is required.")
# Get a summary data frame, removing the intercept
summary_df <- summary(pooled_model, conf.int = TRUE, exponentiate = TRUE) %>%
filter(term != "(Intercept)")
# Combine all variable names for parsing
all_vars <- c(main_exposure, adj_var_names)
pattern <- paste(all_vars, collapse = "|")
processed_results <- summary_df %>%
select(term, estimate, conf.low, conf.high, p.value) %>%
mutate(
group = stringr::str_extract(term, pattern),
Characteristic = stringr::str_remove(term, pattern),
Estimate_CI = sprintf("%.2f (%.2f, %.2f)", estimate, conf.low, conf.high),
p_value_formatted = case_when(
p.value < 0.001 ~ "<0.001",
TRUE ~ sprintf("%.3f", p.value)
)
) %>%
select(group, Characteristic, Estimate_CI, p_value_formatted)
# Conditionally filter for fallacy-safe output
if (fallacy_safe) {
if (!main_exposure %in% processed_results$group) {
stop(paste("Main exposure '", main_exposure, "' not found in model terms.", sep=""))
}
results_to_display <- processed_results %>% filter(group == main_exposure)
footnote_text <- paste("Adjusted for:", paste(adj_var_names, collapse = ", "))
} else {
results_to_display <- processed_results
}
# Create the base kable table
final_table <- kable(
results_to_display[, -1], # Remove helper 'group' column
col.names = c("Characteristic", paste(measure, "(95% CI)"), "p-value"),
align = "lcc",
caption = title,
row.names = FALSE
) %>%
kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE)
# FIX: Only call pack_rows if we are showing the full table (more than one group)
if (!fallacy_safe) {
final_table <- final_table %>%
pack_rows(index = table(factor(results_to_display$group, levels = all_vars)))
} else {
# If fallacy_safe, still add the single header for clarity
final_table <- final_table %>%
pack_rows(main_exposure, 1, nrow(results_to_display))
}
# Add the footnote only if in fallacy-safe mode
if (fallacy_safe) {
final_table <- final_table %>%
footnote(general = footnote_text, footnote_as_chunk = TRUE, general_title = " ")
}
return(final_table)
}
# Full table for an appendix (will be formatted correctly)
publish_pooled_results(pooled_results,
main_exposure = "Smoke100",
adj_var_names = c("AgeCat", "Education"), # <-- New argument
measure = "OR",
title = "Full Model Results for Obesity (Appendix)",
fallacy_safe = FALSE)
publish_pooled_results(pooled_results,
main_exposure = "Smoke100",
adj_var_names = c("AgeCat", "Education"), # <-- New argument
measure = "OR",
title = "Adjusted Odds Ratios for Obesity")
#' Create a Publication-Ready Table for Pooled Model Results (Final, Corrected Version)
#'
#' This function takes a pooled model object from 'mice' and creates a
#' formatted HTML table of effect estimates. It can produce a "fallacy-safe"
#' table showing only the main exposure or a full table with all variables.
#'
#' @param pooled_model A 'mipo' object from `mice::pool()`.
#' @param main_exposure The character string of the main exposure variable.
#' @param adj_var_names A character vector of all adjustment variable names in the model.
#' @param measure A character string for the effect measure (e.g., "OR", "HR").
#' @param title A character string for the table's caption.
#' @param fallacy_safe Logical. If TRUE, only shows the main exposure.
#'
#' @return An HTML table object from 'kableExtra'.
publish_pooled_results <- function(pooled_model,
main_exposure,
adj_var_names,
measure = "OR",
title = "Adjusted Model Results",
fallacy_safe = TRUE) {
# Ensure required packages are loaded
if (!requireNamespace("dplyr", quietly = TRUE)) stop("Package 'dplyr' is required.")
if (!requireNamespace("knitr", quietly = TRUE)) stop("Package 'knitr' is required.")
if (!requireNamespace("kableExtra", quietly = TRUE)) stop("Package 'kableExtra' is required.")
if (!requireNamespace("stringr", quietly = TRUE)) stop("Package 'stringr' is required.")
# Get a summary data frame, removing the intercept
summary_df <- summary(pooled_model, conf.int = TRUE, exponentiate = TRUE) %>%
filter(term != "(Intercept)")
# Combine all variable names for parsing
all_vars <- c(main_exposure, adj_var_names)
pattern <- paste(all_vars, collapse = "|")
processed_results <- summary_df %>%
select(term, estimate, conf.low, conf.high, p.value) %>%
mutate(
group = stringr::str_extract(term, pattern),
Characteristic = stringr::str_remove(term, pattern),
Estimate_CI = sprintf("%.2f (%.2f, %.2f)", estimate, conf.low, conf.high),
p_value_formatted = case_when(
p.value < 0.001 ~ "<0.001",
TRUE ~ sprintf("%.3f", p.value)
)
) %>%
select(group, Characteristic, Estimate_CI, p_value_formatted)
# Conditionally filter for fallacy-safe output
if (fallacy_safe) {
if (!main_exposure %in% processed_results$group) {
stop(paste("Main exposure '", main_exposure, "' not found in model terms.", sep=""))
}
results_to_display <- processed_results %>% filter(group == main_exposure)
footnote_text <- paste("Adjusted for:", paste(adj_var_names, collapse = ", "))
} else {
results_to_display <- processed_results
}
# Create the base kable table
final_table <- kable(
results_to_display[, -1], # Remove helper 'group' column
col.names = c("Characteristic", paste(measure, "(95% CI)"), "p-value"),
align = "lcc",
caption = title,
row.names = FALSE
) %>%
kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE)
# FIX: Only call pack_rows if we are showing the full table (more than one group)
if (!fallacy_safe) {
final_table <- final_table %>%
pack_rows(index = table(factor(results_to_display$group, levels = all_vars)))
} else {
# If fallacy_safe, still add the single header for clarity
final_table <- final_table %>%
pack_rows(main_exposure, 1, nrow(results_to_display))
}
# Add the footnote only if in fallacy-safe mode
if (fallacy_safe) {
final_table <- final_table %>%
footnote(general = footnote_text, footnote_as_chunk = TRUE, general_title = " ")
}
return(final_table)
}
# Load all necessary packages for the analysis
library(dplyr)
library(car)
library(survey)
library(survival)
library(mice)
library(Publish)
library(DataExplorer)
# Set survey option for compatibility
options(survey.want.obsolete = TRUE)
# Load the full, merged dataset with mortality information
dat.full.with.mortality <- readRDS("Data/missingdata/dat.full.with.mortality.RDS")
# --- Create Analytic Variables ---
# 1. Exposure Variable ('exposure.cat')
dat.full.with.mortality$exposure.cat <- car::recode(
dat.full.with.mortality$smoking.age,
"0 = 'Never smoked'; 1:9 = 'Started before 10';
10:14 = 'Started at 10-14'; 15:17 = 'Started at 15-17';
18:20 = 'Started at 18-20'; 21:80 = 'Started after 20';
else = NA",
as.factor = TRUE
)
dat.full.with.mortality$exposure.cat <- factor(
dat.full.with.mortality$exposure.cat,
levels = c("Never smoked", "Started before 10", "Started at 10-14",
"Started at 15-17", "Started at 18-20", "Started after 20")
)
# 2. Survival Time ('stime.since.birth') and Status ('status_all')
dat.full.with.mortality$stime.since.birth <-
((dat.full.with.mortality$age * 12) + dat.full.with.mortality$mort_permth_int) / 12
# 'status_all' is our event indicator, derived from 'mort_stat'. It's essential for the Surv() object.
dat.full.with.mortality$status_all <- dat.full.with.mortality$mort_stat
# 3. Categorical Year ('year.cat')
dat.full.with.mortality$year.cat <- dat.full.with.mortality$year
levels(dat.full.with.mortality$year.cat) <- c(
"1999-2000", "2001-2002", "2003-2004", "2005-2006", "2007-2008",
"2009-2010", "2011-2012", "2013-2014", "2015-2016", "2017-2018"
)
# --- Define the Analytic Cohort & Drop Unnecessary Variables ---
# 4. Apply age restriction (20-79 years)
dat.analytic <- subset(dat.full.with.mortality, age >= 20 & age < 80)
# 5. Drop all raw, intermediate, or unused columns
vars_to_drop <- c(
"age", "born", "smoking.age", "smoked.while.child", "smoking", "year",
"mort_eligstat", "mort_stat", "mort_ucod_leading", "mort_diabetes",
"mort_hyperten", "mort_permth_int", "mort_permth_exm"
)
dat.analytic[vars_to_drop] <- NULL
# Verify the cleaned data
cat("Remaining columns for analysis:\n")
names(dat.analytic)
plot_missing(dat.analytic)
profile_missing(dat.analytic)
# Create the Nelson-Aalen cumulative hazard estimate
# It's a more informative summary of survival than time alone
dat.analytic$nelson_aalen <- nelsonaalen(
dat.analytic,
time = stime.since.birth,
status = status_all
)
# Initialize the predictor matrix
pred_matrix <- make.predictorMatrix(dat.analytic)
# --- DO NOT use these variables AS PREDICTORS ---
# We exclude the raw survival time and identifier variables from being predictors.
pred_matrix[, c("id", "stime.since.birth")] <- 0
# --- DO NOT IMPUTE these variables ---
# These variables are complete, identifiers, or part of the outcome.
pred_matrix[c("id", "sex", "race", "psu", "strata", "survey.weight.new",
"stime.since.birth", "status_all", "year.cat",
"nelson_aalen"), ] <- 0
# Run the imputation. m and maxit are low for demonstration
imputed_data <- mice(
dat.analytic,
m = 2,              # Number of imputed datasets
maxit = 2,         # Number of iterations per imputation
predictorMatrix = pred_matrix,
method = 'pmm',     # Predictive Mean Matching is a good default
seed = 123          # For reproducibility
)
# --- 5. Survival Analysis on Imputed Data (Corrected) ---
# 1. Create an empty list to store the results of each analysis
fit_list <- list()
# 2. Loop through each of the 'm' imputed datasets
for (i in 1:imputed_data$m) {
# Get the i-th completed dataset
completed_data <- complete(imputed_data, i)
# Create a survey design object *specifically for this dataset*
design_i <- svydesign(ids = ~psu,
strata = ~strata,
weights = ~survey.weight.new,
nest = TRUE,
data = completed_data)
# Fit the survey-weighted Cox model using this design
fit_list[[i]] <- svycoxph(Surv(stime.since.birth, status_all) ~ exposure.cat + sex + race + year.cat,
design = design_i)
}
# 3. Pool the results from the list of model fits
pooled_results <- pool(fit_list)
# 4. Display the final, pooled results
print("--- Final Adjusted Cox Model Results (from Pooled Imputed Data) ---")
summary(pooled_results, conf.int = TRUE, exponentiate = TRUE)
# Option A: Fallacy-safe table showing only the main exposure
publish_pooled_results(
pooled_model = pooled_results,
main_exposure = "exposure.cat",
adj_var_names = c("sex", "race", "year.cat"),
measure = "HR",
title = "Adjusted Hazard Ratios for All-Cause Mortality"
)
library(knitr)
library(kableExtra)
# Load all necessary packages for the analysis
library(dplyr)
library(car)
library(survey)
library(survival)
library(mice)
library(Publish)
library(DataExplorer)
library(knitr)
library(kableExtra)
# Set survey option for compatibility
options(survey.want.obsolete = TRUE)
# Load the full, merged dataset with mortality information
dat.full.with.mortality <- readRDS("Data/missingdata/dat.full.with.mortality.RDS")
# Option A: Fallacy-safe table showing only the main exposure
publish_pooled_results(
pooled_model = pooled_results,
main_exposure = "exposure.cat",
adj_var_names = c("sex", "race", "year.cat"),
measure = "HR",
title = "Adjusted Hazard Ratios for All-Cause Mortality"
)
# Option B: Full table for an appendix
publish_pooled_results(
pooled_model = pooled_results,
main_exposure = "exposure.cat",
adj_var_names = c("sex", "race", "year.cat"),
measure = "HR",
title = "Full Adjusted Model Results (for Appendix)",
fallacy_safe = FALSE
)
# Option A: Fallacy-safe table showing only the main exposure
publish_pooled_results(
pooled_model = pooled_results,
main_exposure = "exposure.cat",
adj_var_names = c("sex", "race", "year.cat"),
measure = "HR",
title = "Adjusted Hazard Ratios for All-Cause Mortality"
)
# Option B: Full table for an appendix
publish_pooled_results(
pooled_model = pooled_results,
main_exposure = "exposure.cat",
adj_var_names = c("sex", "race", "year.cat"),
measure = "HR",
title = "Full Adjusted Model Results (for Appendix)",
fallacy_safe = FALSE
)
# install.packages("devtools")
# In README.md
devtools::install_github("ehsanx/svyTable1", build_vignettes = TRUE, dependencies = TRUE)
require(svyTable1)
?svypool
svypooled
?svypooled
devtools::build()
