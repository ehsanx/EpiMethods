outcome = outcome,
w = weights
)
local_data <- local_data[local_data$w > 0 & !is.na(local_data$w), ]
roc_curve <- WeightedROC::WeightedROC(
guess = local_data$predictions,
label = local_data$outcome,
weight = local_data$w
)
WeightedROC::WeightedAUC(roc_curve)
}
# Run the calculation across all replicate weights
result <- survey::withReplicates(
design,
theta = auc_statistic,
return.replicates = TRUE
)
# Manually calculate the confidence interval
auc_estimate <- result$theta
se <- survey::SE(result)
summary_df <- data.frame(
AUC = auc_estimate,
SE = se,
CI_Lower = auc_estimate - 1.96 * se,
CI_Upper = auc_estimate + 1.96 * se
)
rownames(summary_df) <- NULL
# --- PLOTTING LOGIC ---
if (plot) {
# Calculate ROC curve points using the full-sample weights
full_weights <- weights(design, "sampling")
roc_data <- auc_statistic(full_weights, design$variables) # Temporarily re-run to get roc_curve
# Actually need the curve, not just the AUC
predictions <- predict(fit, newdata = design$variables, type = "response")
outcome <- design$variables[[outcome_name]]
if(is.factor(outcome)) {
outcome <- as.numeric(outcome) - 1
}
roc_curve_points <- WeightedROC::WeightedROC(
guess = predictions,
label = outcome,
weight = full_weights
)
plot(roc_curve_points$FPR, roc_curve_points$TPR,
type = 'l',
xlab = "1 - Specificity (FPR)",
ylab = "Sensitivity (TPR)",
main = "Survey-Weighted ROC Curve"
)
abline(0, 1, lty = 2)
title(sub = paste0("AUC = ", round(summary_df$AUC, 3)), adj = 1)
invisible(list(summary = summary_df, roc_data = roc_curve_points))
} else {
return(summary_df)
}
}
# 5. Calculate the AUC
auc0 <- svyAUC1(fit0_rep, rep.design)
auc5 <- svyAUC1(fit5_rep, rep.design)
auc9 <- svyAUC1(fit9_rep, rep.design)
svyAUC <- function(fit, design, plot = FALSE) {
# Input Validation
if (!inherits(design, "svyrep.design")) {
stop("Error: This function requires a replicate-weights survey design object (created with as.svrepdesign).")
}
if (!inherits(fit, "svyglm")) {
stop("Error: This function is designed for 'svyglm' model objects.")
}
outcome_name <- all.vars(fit$formula[[2]])[1]
# Get the outcome column and ensure it is numeric 0/1 before starting.
# outcome_col <- design$variables[[outcome_name]]
# if (is.factor(outcome_col) || is.character(outcome_col)) {
#   # Coerce to factor to get levels, then convert to numeric 0/1
#   outcome_col <- as.factor(outcome_col)
#   design$variables$..outcome_numeric.. <- as.numeric(outcome_col) - 1
# } else {
#   design$variables$..outcome_numeric.. <- outcome_col
# }
# Define the statistic function to be used with replicates
auc_statistic <- function(weights, data) {
model_formula <- formula(fit)
mf <- model.frame(model_formula, data)
mm <- model.matrix(model_formula, mf)
beta <- coef(fit)
eta <- mm %*% beta
predictions <- as.vector(plogis(eta))
outcome <- data[[outcome_name]]
if(is.factor(outcome)) {
outcome <- as.numeric(outcome) - 1
}
local_data <- data.frame(
predictions = predictions,
outcome = outcome,
w = weights
)
local_data <- local_data[local_data$w > 0 & !is.na(local_data$w), ]
roc_curve <- WeightedROC::WeightedROC(
guess = local_data$predictions,
label = local_data$outcome,
weight = local_data$w
)
WeightedROC::WeightedAUC(roc_curve)
}
# Run the calculation across all replicate weights
result <- survey::withReplicates(
design,
theta = auc_statistic,
return.replicates = TRUE
)
# Manually calculate the confidence interval
auc_estimate <- result$theta
se <- survey::SE(result)
summary_df <- data.frame(
AUC = auc_estimate,
SE = se,
CI_Lower = auc_estimate - 1.96 * se,
CI_Upper = auc_estimate + 1.96 * se
)
rownames(summary_df) <- NULL
# --- PLOTTING LOGIC ---
if (plot) {
# Calculate ROC curve points using the full-sample weights
full_weights <- weights(design, "sampling")
roc_data <- auc_statistic(full_weights, design$variables) # Temporarily re-run to get roc_curve
# Actually need the curve, not just the AUC
predictions <- predict(fit, newdata = design$variables, type = "response")
outcome <- design$variables[[outcome_name]]
if(is.factor(outcome)) {
outcome <- as.numeric(outcome) - 1
}
roc_curve_points <- WeightedROC::WeightedROC(
guess = predictions,
label = outcome,
weight = full_weights
)
plot(roc_curve_points$FPR, roc_curve_points$TPR,
type = 'l',
xlab = "1 - Specificity (FPR)",
ylab = "Sensitivity (TPR)",
main = "Survey-Weighted ROC Curve"
)
abline(0, 1, lty = 2)
title(sub = paste0("AUC = ", round(summary_df$AUC, 3)), adj = 1)
invisible(list(summary = summary_df, roc_data = roc_curve_points))
} else {
return(summary_df)
}
}
auc0 <- svyAUC(fit0_rep, rep.design)
srt(rep.design)
str(rep.design)
# 1. Create the full survey design object
w.design <- svydesign(
id = ~ID,
strata = ~province, # Assuming strata is province for this example
weights = ~weight,
data = analytic2
)
# 2. Create a subset of the DESIGN OBJECT
w.design_sub <- subset(w.design, cycle == 11 & province == "North")
# 3. Create the replicate design object from the SUBSETTED DESIGN
rep.design <- as.svrepdesign(w.design_sub)
# Convert OA to a factor with "Control" as the reference level
rep.design$variables$OA <- factor(rep.design$variables$OA, levels = c("Control", "OA"))
# 4. Refit the models using the NEW replicate design object
# The formulas will now be evaluated only on the data within rep.design
fit0_rep <- svyglm(I(CVD=="event") ~ OA, design = rep.design, family = binomial(logit))
fit5_rep <- svyglm(I(CVD=="event") ~ OA + age + sex, design = rep.design, family = binomial(logit))
fit9_rep <- svyglm(I(CVD=="event") ~ OA + age + sex + married + race + edu + income +
bmi + phyact + fruit + bp + diab + doctor + stress + smoke +
drink + age:sex + bmi:diab, design = rep.design, family = binomial(logit))
# 5. Calculate the AUC
auc0 <- svyAUC(fit0_rep, rep.design)
fit0_rep
svyAUC1 <- function(fit, design, plot = FALSE) {
# Input Validation
if (!inherits(design, "svyrep.design")) {
stop("Error: This function requires a replicate-weights survey design object (created with as.svrepdesign).")
}
if (!inherits(fit, "svyglm")) {
stop("Error: This function is designed for 'svyglm' model objects.")
}
outcome_name <- all.vars(fit$formula[[2]])[1]
response_formula <- fit$formula[[2]]
# Get the outcome column and ensure it is numeric 0/1 before starting.
# outcome_col <- design$variables[[outcome_name]]
# if (is.factor(outcome_col) || is.character(outcome_col)) {
#   # Coerce to factor to get levels, then convert to numeric 0/1
#   outcome_col <- as.factor(outcome_col)
#   design$variables$..outcome_numeric.. <- as.numeric(outcome_col) - 1
# } else {
#   design$variables$..outcome_numeric.. <- outcome_col
# }
# Define the statistic function to be used with replicates
auc_statistic <- function(weights, data) {
model_formula <- formula(fit)
mf <- model.frame(model_formula, data)
mm <- model.matrix(model_formula, mf)
beta <- coef(fit)
eta <- mm %*% beta
predictions <- as.vector(plogis(eta))
#outcome <- data[[outcome_name]]
outcome <- eval(response_formula, envir = data)
if(is.factor(outcome)) {
outcome <- as.numeric(outcome) - 1
}
local_data <- data.frame(
predictions = predictions,
outcome = outcome,
w = weights
)
local_data <- local_data[local_data$w > 0 & !is.na(local_data$w), ]
roc_curve <- WeightedROC::WeightedROC(
guess = local_data$predictions,
label = local_data$outcome,
weight = local_data$w
)
WeightedROC::WeightedAUC(roc_curve)
}
# Run the calculation across all replicate weights
result <- survey::withReplicates(
design,
theta = auc_statistic,
return.replicates = TRUE
)
# Manually calculate the confidence interval
auc_estimate <- result$theta
se <- survey::SE(result)
summary_df <- data.frame(
AUC = auc_estimate,
SE = se,
CI_Lower = auc_estimate - 1.96 * se,
CI_Upper = auc_estimate + 1.96 * se
)
rownames(summary_df) <- NULL
# --- PLOTTING LOGIC ---
if (plot) {
# Calculate ROC curve points using the full-sample weights
full_weights <- weights(design, "sampling")
roc_data <- auc_statistic(full_weights, design$variables) # Temporarily re-run to get roc_curve
# Actually need the curve, not just the AUC
predictions <- predict(fit, newdata = design$variables, type = "response")
outcome <- design$variables[[outcome_name]]
if(is.factor(outcome)) {
outcome <- as.numeric(outcome) - 1
}
roc_curve_points <- WeightedROC::WeightedROC(
guess = predictions,
label = outcome,
weight = full_weights
)
plot(roc_curve_points$FPR, roc_curve_points$TPR,
type = 'l',
xlab = "1 - Specificity (FPR)",
ylab = "Sensitivity (TPR)",
main = "Survey-Weighted ROC Curve"
)
abline(0, 1, lty = 2)
title(sub = paste0("AUC = ", round(summary_df$AUC, 3)), adj = 1)
invisible(list(summary = summary_df, roc_data = roc_curve_points))
} else {
return(summary_df)
}
}
# 5. Calculate the AUC
auc0 <- svyAUC1(fit0_rep, rep.design)
auc5 <- svyAUC1(fit5_rep, rep.design)
auc9 <- svyAUC1(fit9_rep, rep.design)
# ===================================================================
# Final, Self-Contained Script to Debug and Confirm svyAUC
# ===================================================================
# --- 1. Load All Necessary Packages ---
cat("--- Loading required packages ---\n")
library(survey)
library(dplyr)
# --- 2. The Final, Working Debugging Function ---
# This version is robust to complex formulas like I(CVD == "event")
debug_svyAUC <- function(fit, design) {
cat("\n--- Inside debug_svyAUC ---\n")
# --- Step A: Validate Inputs ---
if (!inherits(design, "svyrep.design")) {
stop("ERROR: This function requires a replicate-weights survey design object.")
}
if (!inherits(fit, "svyglm")) {
stop("ERROR: This function is designed for 'svyglm' model objects.")
}
# Store the exact response formula from the model
response_formula <- fit$formula[[2]]
cat(paste("  - Stored response formula:", deparse(response_formula), "\n"))
# --- Step B: Define the statistic helper function ---
auc_statistic <- function(weights, data) {
cat("\n  --- Inside auc_statistic helper ---\n")
# --- Step B.1: Calculate predictions for the current replicate ---
model_formula <- formula(fit)
mf <- try(model.frame(model_formula, data), silent = TRUE)
if (inherits(mf, "try-error")) {
cat("    ERROR creating model.frame. Data head:\n")
print(head(data))
stop("Model frame creation failed.")
}
mm <- model.matrix(model_formula, mf)
beta <- coef(fit)
# Handle cases where replicate data has fewer factor levels
if (ncol(mm) != length(beta)) {
beta <- beta[colnames(mm)]
}
eta <- mm %*% beta
predictions <- as.vector(plogis(eta))
# --- Step B.2: Evaluate the outcome using the stored formula ---
outcome <- eval(response_formula, envir = data)
cat(paste("    - Outcome evaluated. Initial class:", class(outcome), "\n"))
local_data <- data.frame(
predictions = predictions,
outcome = as.numeric(outcome), # Ensure numeric for WeightedROC
w = weights
)
local_data <- local_data[local_data$w > 0 & !is.na(local_data$w), ]
# --- FINAL CHECK ---
cat("    - FINAL CHECK: class(guess) is '", class(local_data$predictions), "' and class(label) is '", class(local_data$outcome), "'\n", sep="")
roc_curve <- WeightedROC::WeightedROC(
guess = local_data$predictions,
label = local_data$outcome,
weight = local_data$w
)
WeightedROC::WeightedAUC(roc_curve)
}
# --- Step C: Run withReplicates ---
cat("\n[C] Calling withReplicates()...\n")
result <- survey::withReplicates(design, theta = auc_statistic, return.replicates = TRUE)
cat("[C] withReplicates() completed successfully.\n")
# --- Step D: Format final output ---
auc_estimate <- result$theta
se <- survey::SE(result)
output <- data.frame(
AUC = auc_estimate,
SE = se,
CI_Lower = auc_estimate - 1.96 * se,
CI_Upper = auc_estimate + 1.96 * se
)
rownames(output) <- NULL
cat("\n--- Exiting debug_svyAUC ---\n")
return(output)
}
# ===================================================================
# Standalone Example Using Mock Data
# ===================================================================
cat("\n--- Running Example with Mock Data ---\n")
# 1. Create Mock 'analytic2' data
set.seed(123)
n_obs <- 2000
analytic2 <- data.frame(
ID = 1:n_obs,
province = sample(c("North", "South"), n_obs, replace = TRUE),
weight = runif(n_obs, 10, 100),
cycle = factor(sample(c("11", "21", "31"), n_obs, replace = TRUE)),
CVD = sample(c("event", "no event"), n_obs, replace = TRUE),
OA = sample(c("Control", "OA"), n_obs, replace = TRUE, prob = c(0.8, 0.2)),
age = sample(c("20-29 years", "30-39 years", "40-49 years", "50-59 years"), n_obs, replace = TRUE),
sex = sample(c("Male", "Female"), n_obs, replace = TRUE)
)
cat("  - Mock 'analytic2' data created.\n")
# 2. Create the full survey design object
w.design <- svydesign(
id = ~ID,
strata = ~province,
weights = ~weight,
data = analytic2
)
cat("  - Full 'w.design' created.\n")
# 3. Create a subset of the DESIGN OBJECT
w.design_sub <- subset(w.design, cycle == 11 & province == "North")
cat("  - 'w.design_sub' created by subsetting the design object.\n")
# 4. Create the replicate design object from the SUBSETTED DESIGN
rep.design <- as.svrepdesign(w.design_sub)
cat("  - 'rep.design' (replicate design) created.\n")
# Convert OA to a factor with a specific reference level
rep.design$variables$OA <- factor(rep.design$variables$OA, levels = c("Control", "OA"))
# 5. Refit the models using the NEW replicate design object
cat("  - Fitting models...\n")
fit0_rep <- svyglm(I(CVD=="event") ~ OA, design = rep.design, family = binomial(logit))
fit5_rep <- svyglm(I(CVD=="event") ~ OA + age + sex, design = rep.design, family = binomial(logit))
# 6. Calculate the AUC using the debug function
cat("\n--- Calling debug_svyAUC for the simple model ---\n")
auc0 <- debug_svyAUC(fit0_rep, rep.design)
cat("\n--- Calling debug_svyAUC for the basic model ---\n")
auc5 <- debug_svyAUC(fit5_rep, rep.design)
# 7. Print Final Results
cat("\n\n--- Final Results from a Successful Run ---\n")
cat("Simple Model:\n")
print(auc0)
cat("\nBasic Model:\n")
print(auc5)
svyAUC1 <- function(fit, design) {
# Input Validation
if (!inherits(design, "svyrep.design")) {
stop("Error: This function requires a replicate-weights survey design object (created with as.svrepdesign).")
}
if (!inherits(fit, "svyglm")) {
stop("Error: This function is designed for 'svyglm' model objects.")
}
response_formula <- fit$formula[[2]]
# Define the statistic function to be used with replicates
auc_statistic <- function(weights, data) {
model_formula <- formula(fit)
mf <- model.frame(model_formula, data)
mm <- model.matrix(model_formula, mf)
beta <- coef(fit)
# Handle cases where replicate data has fewer factor levels
if (ncol(mm) != length(beta)) {
beta <- beta[colnames(mm)]
}
eta <- mm %*% beta
predictions <- as.vector(plogis(eta))
outcome <- eval(response_formula, envir = data)
local_data <- data.frame(
predictions = predictions,
outcome = as.numeric(outcome),
w = weights
)
local_data <- local_data[local_data$w > 0 & !is.na(local_data$w), ]
roc_curve <- WeightedROC::WeightedROC(
guess = local_data$predictions,
label = local_data$outcome,
weight = local_data$w
)
WeightedROC::WeightedAUC(roc_curve)
}
# Run the calculation across all replicate weights
result <- survey::withReplicates(
design,
theta = auc_statistic,
return.replicates = TRUE
)
# Manually calculate the confidence interval
auc_estimate <- result$theta
se <- survey::SE(result)
output <- data.frame(
AUC = auc_estimate,
SE = se,
CI_Lower = auc_estimate - 1.96 * se,
CI_Upper = auc_estimate + 1.96 * se
)
rownames(output) <- NULL
return(output)
}
w.design <- svydesign(
id = ~ID,
strata = ~province, # Assuming strata is province for this example
weights = ~weight,
data = analytic2
)
# 2. Create a subset of the DESIGN OBJECT
w.design_sub <- subset(w.design, cycle == 11 & province == "North")
# 3. Create the replicate design object from the SUBSETTED DESIGN
rep.design <- as.svrepdesign(w.design_sub)
# Convert OA to a factor with "Control" as the reference level
rep.design$variables$OA <- factor(rep.design$variables$OA, levels = c("Control", "OA"))
# 4. Refit the models using the NEW replicate design object
# The formulas will now be evaluated only on the data within rep.design
fit0_rep <- svyglm(I(CVD=="event") ~ OA, design = rep.design, family = binomial(logit))
fit5_rep <- svyglm(I(CVD=="event") ~ OA + age + sex, design = rep.design, family = binomial(logit))
fit9_rep <- svyglm(I(CVD=="event") ~ OA + age + sex + married + race + edu + income +
bmi + phyact + fruit + bp + diab + doctor + stress + smoke +
drink + age:sex + bmi:diab, design = rep.design, family = binomial(logit))
str(rep.design)
str(analytic2)
str(analytic.miss)
# 1. Create the full survey design object
w.design <- svydesign(
id = ~ID,
strata = ~province, # Assuming strata is province for this example
weights = ~weight,
data = na.omit(analytic.miss)
)
# 2. Create a subset of the DESIGN OBJECT
w.design_sub <- subset(w.design, cycle == 11 & province == "North")
# 3. Create the replicate design object from the SUBSETTED DESIGN
rep.design <- as.svrepdesign(w.design_sub)
# Convert OA to a factor with "Control" as the reference level
rep.design$variables$OA <- factor(rep.design$variables$OA, levels = c("Control", "OA"))
# 4. Refit the models using the NEW replicate design object
# The formulas will now be evaluated only on the data within rep.design
fit0_rep <- svyglm(I(CVD=="event") ~ OA, design = rep.design, family = binomial(logit))
fit5_rep <- svyglm(I(CVD=="event") ~ OA + age + sex, design = rep.design, family = binomial(logit))
fit9_rep <- svyglm(I(CVD=="event") ~ OA + age + sex + married + race + edu + income +
bmi + phyact + fruit + bp + diab + doctor + stress + smoke +
drink + age:sex + bmi:diab, design = rep.design, family = binomial(logit))
# 5. Calculate the AUC
auc0 <- svyAUC1(fit0_rep, rep.design)
auc5 <- svyAUC1(fit5_rep, rep.design)
auc9 <- svyAUC1(fit9_rep, rep.design)
# 1. Create the full survey design object
w.design <- svydesign(
id = ~1,
strata = ~1, # Assuming strata is province for this example
weights = ~weight,
data = na.omit(analytic.miss)
)
# 1. Create the full survey design object
w.design <- svydesign(
id = ~1,
strata = ~1, # Assuming strata is province for this example
weights = ~weight,
data = na.omit(analytic.miss)
)
# 1. Create the full survey design object
w.design <- svydesign(
id = ~ID,
strata = ~1, # Assuming strata is province for this example
weights = ~weight,
data = na.omit(analytic.miss)
)
