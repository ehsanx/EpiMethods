{
  "hash": "1ab4be44a6aac35520f4bebd7cbbbae7",
  "result": {
    "engine": "knitr",
    "markdown": "## Supervised learning {.unnumbered}\n\nIn this chapter, we will move beyond statistical regression, and introduce some of the popular machine learning methods.\n\nIn the first code chunk, we load necessary R libraries that will be utilized throughout the chapter for various machine learning methods and data visualization.\n\n\n\n\n\n### Read previously saved data\n\nThe second chunk is dedicated to reading previously saved data and formulas from specified file paths, ensuring that the dataset and predefined formulas are available for subsequent analyses.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nObsData <- readRDS(file = \"Data/machinelearning/rhcAnalytic.RDS\")\nlevels(ObsData$Death)=c(\"No\",\"Yes\")\nout.formula1 <- readRDS(file = \"Data/machinelearning/form1.RDS\")\nout.formula2 <- readRDS(file = \"Data/machinelearning/form2.RDS\")\n```\n:::\n\n\n### Ridge, LASSO, and Elastic net\n\nThe traditional regression models (e.g., linear regression, logistic regression) show poor model performance when\n\n-   predictors are highly correlated or\n-   there are many predictors\n\nIn both cases, the variance of the estimated regression coefficients could be highly variable. Hence, the model often results in poor predictions. The general solution to this problem is to reduce the variance at the cost of introducing some bias in the coefficients. This approach is called regularization or shrinking. Since we are interested in overall prediction rather than individual regression coefficients in a prediction context, this shrinkage approach is almost always beneficial for the model's predictive performance. Ridge, LASSO, and Elastic Net are shrinkage machine learning techniques.\n\n-   [Ridge](https://en.wikipedia.org/wiki/Ridge_regression): Penalizes the sum of squared regression coefficients (the so-called $L_2$ penalty). This approach does not remove irrelevant predictors, but minimizes the impact of the irrelevant predictors. There is a hyperparameter called $\\lambda$ (lambda) that determines the amount of shrinkage of the coefficients. The larger $\\lambda$ indicates more penalization of the coefficients. \n\n-   [LASSO](https://en.wikipedia.org/wiki/Lasso_(statistics)): The Least Absolute Shrinkage and Selection Operator (LASSO) is quite similar conceptually to the ridge regression. However, lasso penalizes the sum of the absolute values of regression coefficients (so-called $L_1$ penalty). As a result, a high $\\lambda$ value forces many coefficients to be exactly zero in lasso regression, suggesting a reduced model with fewer predictors, which is never the case in ridge regression.\n\n-   [Elastic Net](https://en.wikipedia.org/wiki/Elastic_net_regularization): The elastic net combines the penalties of ridge regression and lasso to get the best of both methods. Two hyperparameters in the elastic net are $\\alpha$ (alpha) and $\\lambda$.\n\nWe can use the `glmnet` function in R to fit these there models.\n\n::: callout-note\nIn glmnet function, `alpha = 1` for the LASSO, `alpha = 0` for the ridge, and setting alpha to some value between 0 and 1 is the elastic net model.\n:::\n\n\n### Continuous outcome\n\n#### Cross-validation LASSO\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](Images/machinelearning/enet.png){width=818}\n:::\n:::\n\n\nIn this code chunk, we implement a machine learning model training process with a focus on utilizing cross-validation and tuning parameters to optimize the model. Cross-validation is a technique used to assess how well the model will generalize to an independent dataset by partitioning the original dataset into a training set to train the model, and a test set to evaluate it. Here, we specify that we are using a particular type of cross-validation, denoted as \"cv\", and that we will be creating 5 folds (or partitions) of the data, as indicated by `number = 5`.\n\nThe model being trained is specified to use a method known as \"glmnet\", which is capable of performing lasso, ridge, and elastic net regularization regressions. Tuning parameters are crucial in controlling the behavior of our learning algorithm. In this instance, we specify `lambda` and `alpha` as our tuning parameters, which control the amount of regularization applied to the model and the mixing percentage between lasso and ridge regression, respectively. The `tuneGrid` argument is used to specify the exact values of `alpha` and `lambda` that the model should consider during training. The `verbose = FALSE` argument ensures that additional model training details are not printed during the training process. Finally, the trained model is stored in an object for further examination and use.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nctrl <- trainControl(method = \"cv\", number = 5)\nfit.cv.con <- train(out.formula1, \n                    trControl = ctrl,\n                    data = ObsData, method = \"glmnet\",\n                    lambda= 0,\n                    tuneGrid = expand.grid(alpha = 1, lambda = 0),\n                    verbose = FALSE)\nfit.cv.con\n#> glmnet \n#> \n#> 5735 samples\n#>   50 predictor\n#> \n#> No pre-processing\n#> Resampling: Cross-Validated (5 fold) \n#> Summary of sample sizes: 4588, 4588, 4589, 4586, 4589 \n#> Resampling results:\n#> \n#>   RMSE      Rsquared    MAE     \n#>   25.07288  0.06141453  15.14482\n#> \n#> Tuning parameter 'alpha' was held constant at a value of 1\n#> Tuning\n#>  parameter 'lambda' was held constant at a value of 0\n```\n:::\n\n\n#### Cross-validation Ridge\n\nSubsequent code chunks explore Ridge regression and Elastic Net, employing similar methodologies but adjusting tuning parameters accordingly.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nctrl <- trainControl(method = \"cv\", number = 5)\nfit.cv.con <-train(out.formula1, \n                   trControl = ctrl,\n                   data = ObsData, method = \"glmnet\",\n                   lambda= 0,\n                   tuneGrid = expand.grid(alpha = 0, lambda = 0),\n                   verbose = FALSE)\nfit.cv.con\n#> glmnet \n#> \n#> 5735 samples\n#>   50 predictor\n#> \n#> No pre-processing\n#> Resampling: Cross-Validated (5 fold) \n#> Summary of sample sizes: 4589, 4588, 4586, 4588, 4589 \n#> Resampling results:\n#> \n#>   RMSE      Rsquared    MAE     \n#>   25.04858  0.05844794  15.21896\n#> \n#> Tuning parameter 'alpha' was held constant at a value of 0\n#> Tuning\n#>  parameter 'lambda' was held constant at a value of 0\n```\n:::\n\n\n### Binary outcome\n\n#### Cross-validation LASSO\n\nWe then shift to binary outcomes, exploring LASSO and Ridge regression with similar implementations but adjusting for the binary nature of the outcome variable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nctrl<-trainControl(method = \"cv\", number = 5,\n                   classProbs = TRUE,\n                   summaryFunction = twoClassSummary)\nfit.cv.bin<-train(out.formula2, \n                  trControl = ctrl,\n                  data = ObsData, \n                  method = \"glmnet\",\n                  lambda= 0,\n                  tuneGrid = expand.grid(alpha = 1, lambda = 0),\n                  verbose = FALSE,\n                  metric=\"ROC\")\nfit.cv.bin\n#> glmnet \n#> \n#> 5735 samples\n#>   50 predictor\n#>    2 classes: 'No', 'Yes' \n#> \n#> No pre-processing\n#> Resampling: Cross-Validated (5 fold) \n#> Summary of sample sizes: 4587, 4588, 4588, 4589, 4588 \n#> Resampling results:\n#> \n#>   ROC        Sens       Spec     \n#>   0.7550771  0.4729343  0.8541185\n#> \n#> Tuning parameter 'alpha' was held constant at a value of 1\n#> Tuning\n#>  parameter 'lambda' was held constant at a value of 0\n```\n:::\n\n\n-   Not okay to select variables from a shrinkage model, and then use them in a regular regression\n\n#### Cross-validation Ridge\n\n\n::: {.cell}\n\n```{.r .cell-code}\nctrl<-trainControl(method = \"cv\", number = 5,\n                   classProbs = TRUE,\n                   summaryFunction = twoClassSummary)\nfit.cv.bin<-train(out.formula2, trControl = ctrl,\n               data = ObsData, method = \"glmnet\",\n               lambda= 0,\n               tuneGrid = expand.grid(alpha = 0,  \n                                      lambda = 0),\n               verbose = FALSE,\n               metric=\"ROC\")\nfit.cv.bin\n#> glmnet \n#> \n#> 5735 samples\n#>   50 predictor\n#>    2 classes: 'No', 'Yes' \n#> \n#> No pre-processing\n#> Resampling: Cross-Validated (5 fold) \n#> Summary of sample sizes: 4587, 4588, 4588, 4589, 4588 \n#> Resampling results:\n#> \n#>   ROC        Sens      Spec     \n#>   0.7554483  0.464984  0.8546388\n#> \n#> Tuning parameter 'alpha' was held constant at a value of 0\n#> Tuning\n#>  parameter 'lambda' was held constant at a value of 0\n```\n:::\n\n\n#### Cross-validation Elastic net\n\n-   Alpha = mixing parameter\n-   Lambda = regularization or tuning parameter\n-   We can use `expand.grid` for model tuning\n\n\n::: {.cell}\n\n```{.r .cell-code}\nctrl<-trainControl(method = \"cv\", number = 5,\n                   classProbs = TRUE,\n                   summaryFunction = twoClassSummary)\nfit.cv.bin<-train(out.formula2, trControl = ctrl,\n               data = ObsData, method = \"glmnet\",\n               tuneGrid = expand.grid(alpha = seq(0.1,.2,by = 0.05),  \n                                      lambda = seq(0.05,0.3,by = 0.05)),\n               verbose = FALSE,\n               metric=\"ROC\")\nfit.cv.bin\n#> glmnet \n#> \n#> 5735 samples\n#>   50 predictor\n#>    2 classes: 'No', 'Yes' \n#> \n#> No pre-processing\n#> Resampling: Cross-Validated (5 fold) \n#> Summary of sample sizes: 4588, 4588, 4589, 4588, 4587 \n#> Resampling results across tuning parameters:\n#> \n#>   alpha  lambda  ROC        Sens          Spec     \n#>   0.10   0.05    0.7528933  0.3730775403  0.8987122\n#>   0.10   0.10    0.7493624  0.2752095601  0.9357902\n#>   0.10   0.15    0.7447854  0.1728726097  0.9685661\n#>   0.10   0.20    0.7391302  0.0874276261  0.9854911\n#>   0.10   0.25    0.7326377  0.0253336296  0.9970452\n#>   0.10   0.30    0.7255479  0.0014900683  0.9997315\n#>   0.15   0.05    0.7518810  0.3502240658  0.9073089\n#>   0.15   0.10    0.7454985  0.2205733121  0.9532532\n#>   0.15   0.15    0.7362845  0.0948792020  0.9819986\n#>   0.15   0.20    0.7247421  0.0183783317  0.9959706\n#>   0.15   0.25    0.7166228  0.0004962779  1.0000000\n#>   0.15   0.30    0.7106139  0.0000000000  1.0000000\n#>   0.20   0.05    0.7505981  0.3323383085  0.9151010\n#>   0.20   0.10    0.7397579  0.1684011703  0.9691030\n#>   0.20   0.15    0.7241801  0.0387442440  0.9916717\n#>   0.20   0.20    0.7138667  0.0009925558  0.9997315\n#>   0.20   0.25    0.7068643  0.0000000000  1.0000000\n#>   0.20   0.30    0.6974506  0.0000000000  1.0000000\n#> \n#> ROC was used to select the optimal model using the largest value.\n#> The final values used for the model were alpha = 0.1 and lambda = 0.05.\nplot(fit.cv.bin)\n```\n\n::: {.cell-output-display}\n![](machinelearning5_files/figure-html/cvbinenet-1.png){width=672}\n:::\n:::\n\n\n#### Decision tree\n\nDecision trees are then introduced and implemented, with visualizations and evaluation metrics provided to assess their performance.\n\n-   Decision tree\n    -   Referred to as Classification and regression trees or CART\n    -   Covers\n        -   Classification (categorical outcome)\n        -   Regression (continuous outcome)\n    -   Flexible to incorporate non-linear effects automatically\n        -   No need to specify higher order terms / interactions\n    -   Unstable, prone to overfitting, suffers from high variance\n\n##### Simple CART\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrequire(rpart)\nsummary(ObsData$DASIndex) # Duke Activity Status Index\n#>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n#>   11.00   16.06   19.75   20.50   23.43   33.00\ncart.fit <- rpart(Death~DASIndex, data = ObsData)\npar(mfrow = c(1,1), xpd = NA)\nplot(cart.fit)\ntext(cart.fit, use.n = TRUE)\n```\n\n::: {.cell-output-display}\n![](machinelearning5_files/figure-html/cart-1.png){width=672}\n:::\n\n```{.r .cell-code}\nprint(cart.fit)\n#> n= 5735 \n#> \n#> node), split, n, loss, yval, (yprob)\n#>       * denotes terminal node\n#> \n#> 1) root 5735 2013 Yes (0.3510026 0.6489974)  \n#>   2) DASIndex>=24.92383 1143  514 No (0.5503062 0.4496938)  \n#>     4) DASIndex>=29.14648 561  199 No (0.6452763 0.3547237) *\n#>     5) DASIndex< 29.14648 582  267 Yes (0.4587629 0.5412371) *\n#>   3) DASIndex< 24.92383 4592 1384 Yes (0.3013937 0.6986063) *\nrequire(rattle)\nrequire(rpart.plot)\nrequire(RColorBrewer)\nfancyRpartPlot(cart.fit, caption = NULL)\n```\n\n::: {.cell-output-display}\n![](machinelearning5_files/figure-html/cart-2.png){width=672}\n:::\n:::\n\n\n###### AUC\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrequire(pROC)\nobs.y2<-ObsData$Death\npred.y2 <- as.numeric(predict(cart.fit, type = \"prob\")[, 2])\nrocobj <- roc(obs.y2, pred.y2)\n#> Setting levels: control = No, case = Yes\n#> Setting direction: controls < cases\nrocobj\n#> \n#> Call:\n#> roc.default(response = obs.y2, predictor = pred.y2)\n#> \n#> Data: pred.y2 in 2013 controls (obs.y2 No) < 3722 cases (obs.y2 Yes).\n#> Area under the curve: 0.5912\nplot(rocobj)\n```\n\n::: {.cell-output-display}\n![](machinelearning5_files/figure-html/auc1-1.png){width=672}\n:::\n\n```{.r .cell-code}\nauc(rocobj)\n#> Area under the curve: 0.5912\n```\n:::\n\n\n##### Complex CART\n\nMore variables\n\n\n::: {.cell}\n\n```{.r .cell-code}\nout.formula2\n#> Death ~ Disease.category + Cancer + Cardiovascular + Congestive.HF + \n#>     Dementia + Psychiatric + Pulmonary + Renal + Hepatic + GI.Bleed + \n#>     Tumor + Immunosupperssion + Transfer.hx + MI + age + sex + \n#>     edu + DASIndex + APACHE.score + Glasgow.Coma.Score + blood.pressure + \n#>     WBC + Heart.rate + Respiratory.rate + Temperature + PaO2vs.FIO2 + \n#>     Albumin + Hematocrit + Bilirubin + Creatinine + Sodium + \n#>     Potassium + PaCo2 + PH + Weight + DNR.status + Medical.insurance + \n#>     Respiratory.Diag + Cardiovascular.Diag + Neurological.Diag + \n#>     Gastrointestinal.Diag + Renal.Diag + Metabolic.Diag + Hematologic.Diag + \n#>     Sepsis.Diag + Trauma.Diag + Orthopedic.Diag + race + income + \n#>     RHC.use\nrequire(rpart)\ncart.fit <- rpart(out.formula2, data = ObsData)\n```\n:::\n\n\n##### CART Variable importance\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncart.fit$variable.importance\n#>            DASIndex              Cancer               Tumor                 age \n#>         123.2102455          33.4559400          32.5418433          24.0804860 \n#>   Medical.insurance                 WBC                 edu Cardiovascular.Diag \n#>          14.5199953           5.6673997           3.7441554           3.6449371 \n#>          Heart.rate      Cardiovascular         Trauma.Diag               PaCo2 \n#>           3.4059248           3.1669125           0.5953098           0.2420672 \n#>           Potassium              Sodium             Albumin \n#>           0.2420672           0.2420672           0.1984366\n```\n:::\n\n\n###### AUC\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrequire(pROC)\nobs.y2<-ObsData$Death\npred.y2 <- as.numeric(predict(cart.fit, type = \"prob\")[, 2])\nrocobj <- roc(obs.y2, pred.y2)\n#> Setting levels: control = No, case = Yes\n#> Setting direction: controls < cases\nrocobj\n#> \n#> Call:\n#> roc.default(response = obs.y2, predictor = pred.y2)\n#> \n#> Data: pred.y2 in 2013 controls (obs.y2 No) < 3722 cases (obs.y2 Yes).\n#> Area under the curve: 0.5981\nplot(rocobj)\n```\n\n::: {.cell-output-display}\n![](machinelearning5_files/figure-html/auc2-1.png){width=672}\n:::\n\n```{.r .cell-code}\nauc(rocobj)\n#> Area under the curve: 0.5981\n```\n:::\n\n\n##### Cross-validation CART\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(504)\nrequire(caret)\nctrl<-trainControl(method = \"cv\", number = 5, \n                   classProbs = TRUE,\n                   summaryFunction = twoClassSummary)\n# fit the model with formula = out.formula2\nfit.cv.bin<-train(out.formula2, trControl = ctrl,\n               data = ObsData, method = \"rpart\",\n              metric=\"ROC\")\nfit.cv.bin\n#> CART \n#> \n#> 5735 samples\n#>   50 predictor\n#>    2 classes: 'No', 'Yes' \n#> \n#> No pre-processing\n#> Resampling: Cross-Validated (5 fold) \n#> Summary of sample sizes: 4587, 4589, 4587, 4589, 4588 \n#> Resampling results across tuning parameters:\n#> \n#>   cp           ROC        Sens       Spec     \n#>   0.007203179  0.6304911  0.2816488  0.9086574\n#>   0.039741679  0.5725283  0.2488649  0.8981807\n#>   0.057128664  0.5380544  0.1287804  0.9473284\n#> \n#> ROC was used to select the optimal model using the largest value.\n#> The final value used for the model was cp = 0.007203179.\n# extract results from each test data \nsummary.res <- fit.cv.bin$resample\nsummary.res\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"ROC\"],\"name\":[1],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"Sens\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"Spec\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"Resample\"],\"name\":[4],\"type\":[\"chr\"],\"align\":[\"left\"]}],\"data\":[{\"1\":\"0.6847220\",\"2\":\"0.3746898\",\"3\":\"0.8590604\",\"4\":\"Fold1\"},{\"1\":\"0.6729625\",\"2\":\"0.2985075\",\"3\":\"0.8924731\",\"4\":\"Fold2\"},{\"1\":\"0.6076153\",\"2\":\"0.2754342\",\"3\":\"0.9287634\",\"4\":\"Fold5\"},{\"1\":\"0.5873154\",\"2\":\"0.2238806\",\"3\":\"0.9274194\",\"4\":\"Fold4\"},{\"1\":\"0.5998401\",\"2\":\"0.2357320\",\"3\":\"0.9355705\",\"4\":\"Fold3\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n### Ensemble methods (Type I)\n\nWe explore ensemble methods, specifically bagging and boosting, through implementation and evaluation in the context of binary outcomes.\n\nTraining same model to different samples (of the same data)\n\n#### Cross-validation bagging\n\n-   Bagging or bootstrap aggregation\n    -   independent bootstrap samples (sampling with replacement, B times),\n    -   applies CART on each i (no prunning)\n    -   Average the resulting predictions\n    -   Reduces variance as a result of using bootstrap\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(504)\nrequire(caret)\nctrl<-trainControl(method = \"cv\", number = 5,\n                   classProbs = TRUE,\n                   summaryFunction = twoClassSummary)\n# fit the model with formula = out.formula2\nfit.cv.bin<-train(out.formula2, trControl = ctrl,\n               data = ObsData, method = \"bag\",\n               bagControl = bagControl(fit = ldaBag$fit, \n                                       predict = ldaBag$pred, \n                                       aggregate = ldaBag$aggregate),\n               metric=\"ROC\")\n#> Warning: executing %dopar% sequentially: no parallel backend registered\nfit.cv.bin\n#> Bagged Model \n#> \n#> 5735 samples\n#>   50 predictor\n#>    2 classes: 'No', 'Yes' \n#> \n#> No pre-processing\n#> Resampling: Cross-Validated (5 fold) \n#> Summary of sample sizes: 4587, 4589, 4587, 4589, 4588 \n#> Resampling results:\n#> \n#>   ROC        Sens       Spec     \n#>   0.7506666  0.4485809  0.8602811\n#> \n#> Tuning parameter 'vars' was held constant at a value of 63\n```\n:::\n\n\n-   Bagging improves prediction accuracy\n    -   over prediction using a single tree\n-   Looses interpretability\n    -   as this is an average of many diagrams now\n-   But we can get a summary of the importance of each variable\n\n##### Bagging Variable importance\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncaret::varImp(fit.cv.bin, scale = FALSE)\n#> ROC curve variable importance\n#> \n#>   only 20 most important variables shown (out of 50)\n#> \n#>                    Importance\n#> age                    0.6159\n#> APACHE.score           0.6140\n#> DASIndex               0.5962\n#> Cancer                 0.5878\n#> Creatinine             0.5835\n#> Tumor                  0.5807\n#> blood.pressure         0.5697\n#> Glasgow.Coma.Score     0.5656\n#> Disease.category       0.5641\n#> Temperature            0.5584\n#> DNR.status             0.5572\n#> Hematocrit             0.5525\n#> Weight                 0.5424\n#> Bilirubin              0.5397\n#> income                 0.5319\n#> Immunosupperssion      0.5278\n#> RHC.use                0.5263\n#> Dementia               0.5252\n#> Congestive.HF          0.5250\n#> Hematologic.Diag       0.5250\n```\n:::\n\n\n#### Cross-validation boosting\n\n-   Boosting\n    -   sequentially updated/weighted bootstrap based on previous learning\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(504)\nrequire(caret)\nctrl<-trainControl(method = \"cv\", number = 5,\n                   classProbs = TRUE,\n                   summaryFunction = twoClassSummary)\n# fit the model with formula = out.formula2\nfit.cv.bin<-train(out.formula2, trControl = ctrl,\n               data = ObsData, method = \"gbm\",\n               verbose = FALSE,\n               metric=\"ROC\")\nfit.cv.bin\n#> Stochastic Gradient Boosting \n#> \n#> 5735 samples\n#>   50 predictor\n#>    2 classes: 'No', 'Yes' \n#> \n#> No pre-processing\n#> Resampling: Cross-Validated (5 fold) \n#> Summary of sample sizes: 4587, 4589, 4587, 4589, 4588 \n#> Resampling results across tuning parameters:\n#> \n#>   interaction.depth  n.trees  ROC        Sens       Spec     \n#>   1                   50      0.7218938  0.2145970  0.9505647\n#>   1                  100      0.7410292  0.2980581  0.9234228\n#>   1                  150      0.7483014  0.3487142  0.9030028\n#>   2                   50      0.7414513  0.2960631  0.9263816\n#>   2                  100      0.7534264  0.3869684  0.8917212\n#>   2                  150      0.7575826  0.4187512  0.8777477\n#>   3                   50      0.7496078  0.3626125  0.9070358\n#>   3                  100      0.7579645  0.4078244  0.8764076\n#>   3                  150      0.7637074  0.4445909  0.8702298\n#> \n#> Tuning parameter 'shrinkage' was held constant at a value of 0.1\n#> \n#> Tuning parameter 'n.minobsinnode' was held constant at a value of 10\n#> ROC was used to select the optimal model using the largest value.\n#> The final values used for the model were n.trees = 150, interaction.depth =\n#>  3, shrinkage = 0.1 and n.minobsinnode = 10.\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(fit.cv.bin)\n```\n\n::: {.cell-output-display}\n![](machinelearning5_files/figure-html/plotcv-1.png){width=672}\n:::\n:::\n\n\n### Ensemble methods (Type II)\n\nWe introduce the concept of Super Learner, providing external resources for further exploration.\n\nTraining different models on the same data\n\n#### Super Learner\n\n-   Large number of candidate learners (CL) with different strengths\n    -   Parametric (logistic)\n    -   Non-parametric (CART)\n-   Cross-validation: CL applied on training data, prediction made on test data\n-   Final prediction uses a weighted version of all predictions\n    -   Weights = coef of Observed outcome \\~ prediction from each CL\n\n#### Steps\n\nRefer to [this tutorial](https://ehsanx.github.io/TMLEworkshop/g-computation-using-ml.html#g-comp-using-superlearner) for steps and examples! Refer to the [next chapter](machinelearningCausal.html) for more details.\n\n### Video content (optional)\n\n::: callout-tip\nFor those who prefer a video walkthrough, feel free to watch the video below, which offers a description of an earlier version of the above content.\n:::\n\n::: {style=\"position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;\"}\n<iframe src=\"https://www.youtube.com/embed/lzr8GOq_Ph0\" style=\"position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;\" allowfullscreen>\n\n</iframe>\n:::\n\n::: {style=\"position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;\"}\n<iframe src=\"https://www.youtube.com/embed/Q59yffGr8qI\" style=\"position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;\" allowfullscreen>\n\n</iframe>\n:::\n\n::: {style=\"position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;\"}\n<iframe src=\"https://www.youtube.com/embed/igBfnECna_8\" style=\"position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;\" allowfullscreen>\n\n</iframe>\n:::\n\n::: callout-tip\nThe following is a brief exercise of super learners in the propensity score context, but we will explore more about this topic in the [next chapter](machinelearningCausal.html).\n:::\n\n::: {style=\"position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;\"}\n<iframe src=\"https://www.youtube.com/embed/wiseRA2KQ94\" style=\"position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;\" allowfullscreen>\n\n</iframe>\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}