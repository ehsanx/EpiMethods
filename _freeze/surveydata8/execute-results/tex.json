{
  "hash": "2c99b92108637b3a70e91a7af3939791",
  "result": {
    "markdown": "## NHANES: Subsetting {.unnumbered}\n\nThe tutorial demonstrates how to work with subset of complex survey data, specifically focusing on an NHANES example.\n\nThe required packages are loaded.\n\n\n\n::: {.cell hash='surveydata8_cache/pdf/setup_8aced0c618e8f5da586b33958b6878be'}\n\n```{.r .cell-code}\n# Load required packages\nlibrary(survey)\nlibrary(Publish)\nlibrary(DataExplorer)\n```\n:::\n\n\n\n### Load data\n\nSurvey data is loaded into the R environment.\n\n\n\n::: {.cell hash='surveydata8_cache/pdf/load_a507376b6ed460bab6d0326dffc68d66'}\n\n```{.r .cell-code}\nload(\"Data/surveydata/NHANES17.RData\")\nls()\n#> [1] \"analytic\"           \"analytic.with.miss\" \"has_annotations\"\n```\n:::\n\n\n\n### Check missingness\n\nA subset of variables is selected, and the presence of missing data is visualized. \n\n\n\n::: {.cell hash='surveydata8_cache/pdf/miss0_b82cf5363b469df3a3b437439f2b3d0d'}\n\n```{.r .cell-code}\nVars <- c(\"ID\", \n          \"weight\", \n          \"psu\", \n          \"strata\", \n          \"gender\", \n          \"born\", \n          \"race\", \n          \"bmi\", \n          \"cholesterol\", \n          \"diabetes\")\nanalytic.full.data <- analytic.with.miss[,Vars]\n```\n:::\n\n\n\nA new variable is also created to categorize cholesterol levels as \"healthy\" or \"unhealthy.\"\n\n\n\n::: {.cell hash='surveydata8_cache/pdf/miss02jkfh_f7683ef7f1422dce6cee5679d02ab441'}\n\n```{.r .cell-code}\nanalytic.full.data$cholesterol.bin <- ifelse(analytic.full.data$cholesterol <200, \"healthy\", \"unhealthy\")\nanalytic.full.data$cholesterol <- NULL\n\nrequire(DataExplorer)\nplot_missing(analytic.full.data)\n```\n\n::: {.cell-output-display}\n![](surveydata8_files/figure-pdf/miss02jkfh-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n### Subsetting Complex Survey data\n\nWe are subsetting based on whether the subjects have missing observation (e.g., only retaining those with complete information). This is often an eligibility criteria in studies. In missing data analysis, we will learn more about more appropriate approaches.\n\n\n\n::: {.cell hash='surveydata8_cache/pdf/subset0_be58d798f7c085c472ada73d766865d2'}\n\n```{.r .cell-code}\ndim(analytic.full.data)\n#> [1] 9254   10\nhead(analytic.full.data$ID) # full data\n#> [1] 93703 93704 93705 93706 93707 93708\nanalytic.complete.case.only <- as.data.frame(na.omit(analytic.full.data))\ndim(analytic.complete.case.only)\n#> [1] 6636   10\nhead(analytic.complete.case.only$ID) # complete case\n#> [1] 93705 93706 93707 93708 93709 93711\nhead(analytic.full.data$ID[analytic.full.data$ID %in% analytic.complete.case.only$ID])\n#> [1] 93705 93706 93707 93708 93709 93711\n```\n:::\n\n\n\nBelow we show how to identify who has missing observations vs not based on full (`analytic.full.data`) and complete case (`analytic.complete.case.only`) data. See Heeringa et al (2010) book page 114 (section 4.5.3 \"Preparation for Subclass analyses\") and also page 218 (section 7.5.4 \"appropriate analysis: incorporating all Sample Design Features\"). This is done for 2 reasons:\n\n-   full complex survey design structure is taken into account, so that variance estimation is done correctly. If one or more PSU were excluded because none of the complete cases were observed in those PSU, the sub-population (complete cases) will not have complete information of how many PSU were actually present in the original complex design. Then in the population, a reduced number of PSUs would be used to calculate variance (number of SPU is a component of the variance calculation formula, see equation (5.2) in Heeringa et al (2010) textbook. Same is true for strata.), and will result in a wrong/biased variance estimate. Also see West et al. doi: 10.1177/1536867X0800800404\n-   size of sub-population (here, those with complete cases) is recognized as a random variable; not just a fixed size.\n\n\n\n::: {.cell hash='surveydata8_cache/pdf/subset1_b12208da20ed05f0cda844fc030930a8'}\n\n```{.r .cell-code}\n# assign missing indicator\nanalytic.full.data$miss <- 1 \n# assign missing indicator = 0 if the observation is available\nanalytic.full.data$miss[analytic.full.data$ID %in% analytic.complete.case.only$ID] <- 0\n```\n:::\n\n::: {.cell hash='surveydata8_cache/pdf/subset2_08fb80fc9af4d4282ccbbbafdacb8694'}\n\n```{.r .cell-code}\ntable(analytic.full.data$miss)\n#> \n#>    0    1 \n#> 6636 2618\n# IDs not in complete case data\nhead(analytic.full.data$ID[analytic.full.data$miss==1])\n#> [1] 93703 93704 93710 93720 93724 93725\n# IDs in complete case data\nhead(analytic.full.data$ID[analytic.full.data$miss==0])\n#> [1] 93705 93706 93707 93708 93709 93711\n```\n:::\n\n\n\n### Logistic regression on sub-population\n\nA logistic regression model is run on the subset of data that has no missing values. Here, it distinguishes between correct and incorrect approaches to account for the complex survey design.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrequire(survey)\nrequire(Publish)\nmodel.formula <- as.formula(\"I(cholesterol.bin=='healthy')~\n                            diabetes+gender+born+race+bmi\")\n```\n:::\n\n\n\n#### Wrong approach\n\n\n\n::: {.cell hash='surveydata8_cache/pdf/wrong1_b66d59b0d9d5f774989bb80ec242b4e3'}\n\n```{.r .cell-code}\nw.design.wrong <- svydesign(ids=~psu, \n                       weights=~weight, \n                       strata=~strata,\n                       data = analytic.complete.case.only, #wrong!!\n                       nest = TRUE)\n```\n:::\n\n\n\n#### Correct approach\n\n\n\n::: {.cell hash='surveydata8_cache/pdf/correct1_d0345656ac55195ec92f34c25f860414'}\n\n```{.r .cell-code}\nw.design0 <- svydesign(ids=~psu, \n                       weights=~weight, \n                       strata=~strata,\n                       data = analytic.full.data, \n                       nest = TRUE)\n\n# retain only those that have complete observation / no missing\nw.design <- subset(w.design0, miss == 0)# this is the subset design\n```\n:::\n\n\n\n#### Full model\n\n\n\n::: {.cell hash='surveydata8_cache/pdf/full_36251fb02181a8efe64a7ab84e5a8724'}\n\n```{.r .cell-code}\nfit <- svyglm(model.formula, family = quasibinomial, \n              design = w.design) # subset design\npublish(fit)\n#>  Variable                            Units Coefficient           CI.95     p-value \n#>  diabetes                               No         Ref                             \n#>                                        Yes        0.38     [0.20;0.57]   0.0049202 \n#>    gender                           Female         Ref                             \n#>                                       Male        0.22     [0.03;0.40]   0.0568343 \n#>      born Born in 50 US states or Washingt         Ref                             \n#>                                     Others       -0.66   [-0.84;-0.47]   0.0002304 \n#>                                    Refused      -12.26 [-13.65;-10.88]     < 1e-04 \n#>      race                            Black         Ref                             \n#>                                   Hispanic        0.20    [-0.08;0.47]   0.2075536 \n#>                                      Other       -0.17    [-0.38;0.03]   0.1439474 \n#>                                      White       -0.37   [-0.66;-0.09]   0.0355030 \n#>       bmi                                        -0.04   [-0.05;-0.02]   0.0007697\n```\n:::\n\n\n\n### Variable selection\n\nFinally, we discuss variable selection methods. We employ backward elimination to determine which variables are significant predictors while retaining an important variable in the model. If unsure about usefulness of some (gender, born, race, bmi) variables in predicting the outcome, check via backward elimination while keeping important variable (diabetes, say, that has been established in the literature) in the model\n\n\n\n::: {.cell hash='surveydata8_cache/pdf/varselect_83e3f7b4c983b99b0b352da3f5539809'}\n\n```{.r .cell-code}\nmodel.formula <- as.formula(\"I(cholesterol.bin=='healthy')~\n                            diabetes+gender+born+race+bmi\")\n\nscope <- list(upper = ~ diabetes+gender+born+race+bmi, lower = ~ diabetes)\n\nfit <- svyglm(model.formula, design=w.design, # subset design\n              family=quasibinomial)\n\nfitstep <- step(fit,  scope = scope, trace = FALSE, direction = \"backward\")\npublish(fitstep) # final model\n#>  Variable                            Units Coefficient           CI.95     p-value \n#>  diabetes                               No         Ref                             \n#>                                        Yes        0.38     [0.20;0.57]   0.0049202 \n#>    gender                           Female         Ref                             \n#>                                       Male        0.22     [0.03;0.40]   0.0568343 \n#>      born Born in 50 US states or Washingt         Ref                             \n#>                                     Others       -0.66   [-0.84;-0.47]   0.0002304 \n#>                                    Refused      -12.26 [-13.65;-10.88]     < 1e-04 \n#>      race                            Black         Ref                             \n#>                                   Hispanic        0.20    [-0.08;0.47]   0.2075536 \n#>                                      Other       -0.17    [-0.38;0.03]   0.1439474 \n#>                                      White       -0.37   [-0.66;-0.09]   0.0355030 \n#>       bmi                                        -0.04   [-0.05;-0.02]   0.0007697\n```\n:::\n\n\n\nAlso see [@subpopulation] for further details.\n\n### Video content (optional)\n\n::: callout-tip\nFor those who prefer a video walkthrough, feel free to watch the video below, which offers a description of an earlier version of the above content.\n:::\n\n::: {style=\"position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;\"}\n<iframe src=\"https://www.youtube.com/embed/A8p2zu-JlBU\" style=\"position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;\" allowfullscreen>\n\n</iframe>\n:::\n\n### References\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}